"""This module contains the output handlers. These handlers create 
output files from the n-best lists generated by the ``Decoder``. They
can be activated via --outputs.
"""

from abc import abstractmethod
import os
import errno
import logging
from cam.sgnmt import utils


class OutputHandler(object):
    """Interface for output handlers. """
    
    def __init__(self):
        """ Empty constructor """
        pass
    
    @abstractmethod
    def write_hypos(self, all_hypos):
        """This method writes output files to the file system. The
        configuration parameters such as output paths should already
        have been provided via constructor arguments.
        
        Args:
            all_hypos (list): list of nbest lists of hypotheses
        
        Raises:
            IOError. If something goes wrong while writing to the disk
        """
        raise NotImplementedError
    

class TextOutputHandler(OutputHandler):
    """Writes the first best hypotheses to a plain text file """
    
    def __init__(self, path):
        """Creates a plain text output handler to write to ``path`` """
        super(TextOutputHandler, self).__init__()
        self.path = path
        
    def write_hypos(self, all_hypos):
        """Writes the hypotheses in ``all_hypos`` to ``path`` """
        with open(self.path, "w") as f:
            for hypos in all_hypos:
                f.write(' '.join(str(w) for w in hypos[0].trgt_sentence))
                f.write("\n")
  
                
class NBestOutputHandler(OutputHandler):
    """Produces a n-best file in Moses format. The third part of each 
    entry is used to store the separated unnormalized predictor scores.
    Note that the sentence IDs are shifted: Moses n-best files start 
    with the index 0, but in SGNMT and HiFST we usually refer to the 
    first sentence with 1 (e.g. in lattice directories or --range)
    """
    
    def __init__(self, path, predictor_names, start_sen_id):
        """Creates a Moses n-best list output handler.
        
        Args:
            path (string):  Path to the n-best file to write
            predictor_names: Names of the predictors whose scores
                             should be included in the score breakdown
                             in the n-best list
            start_sen_id: ID of the first sentence
        """
        super(NBestOutputHandler, self).__init__()
        self.path = path
        self.start_sen_id = start_sen_id
        self.predictor_names = []
        name_count = {}
        for name in predictor_names:
            if not name in name_count:
                name_count[name] = 1
                final_name = name
            else:
                name_count[name] += 1
                final_name = "%s%d" % (name, name_count[name])
            self.predictor_names.append(final_name.replace("_", "0"))
        
    def write_hypos(self, all_hypos):
        """Writes the hypotheses in ``all_hypos`` to ``path`` """
        with open(self.path, "w") as f:
            n_predictors = len(self.predictor_names)
            idx = self.start_sen_id
            for hypos in all_hypos:
                for hypo in hypos:
                    f.write("%d ||| %s ||| %s ||| %f" %
                            (idx,
                             ' '.join(str(w) for w in hypo.trgt_sentence),
                             ' '.join("%s= %f" % (
                                  self.predictor_names[i],
                                  sum([s[i][0] for s in hypo.score_breakdown]))
                                      for i in xrange(n_predictors)),
                             hypo.total_score))
                    f.write("\n")
                idx += 1


class FSTOutputHandler(OutputHandler):
    """This output handler creates OpenFST 1.5 text formatted FSTs with
    with sparse tuple arcs from the n-best lists from the decoder. The
    predictor scores are kept separately in the sparse tuples. Note 
    that this means that the parameter --combination_scheme might not 
    be visible in the lattices because predictor scores are not 
    combined. Also note that the text format changed somewhere between
    OpenFST 1.3 and 1.5. This output handler uses the new format:
    0,1,feat_1,2,feat_2,5,feat_5... 
    The order in the sparse tuples corresponds to the order of the
    predictors in --predictors.
    """
    
    def __init__(self, path, start_sen_id):
        """Creates a sparse tuple FST output handler.
        
        Args:
            path (string):  Path to the VECLAT directory to create
            start_sen_id (int):  ID of the first sentence
        """
        super(FSTOutputHandler, self).__init__()
        self.path = path
        self.start_sen_id = start_sen_id
        self.file_pattern = path + "/%d.fst.txt" 
      
    def write_weight(self, score_breakdown):
        """Helper method to create the weight string """
        els = ['0']
        for (idx,score) in enumerate(score_breakdown):
            els.append(str(idx+1))
            # We need to take the negative here since the tropical
            # FST arc type expects negative log probs instead of log probs
            els.append(str(-score[0]))
        return ','.join(els)

    def write_hypos(self, all_hypos):
        """Writes FST files in OpenFST 1.5 text format with sparse 
        tuples for each sentence in ``all_hypos``. The created lattices
        are not optimized in any way: We create a distinct path for
        each entry in ``all_hypos``. We advise you to determinize/
        minimize them if you are planning to use them for further 
        processing. However, keep in mind that SGNMT uses the id 0 for 
        UNK, and OpenFST marks epsilon arcs that way. You can resolve 
        this clash by using fstrelabel after fstcompile.
        
        Args:
            all_hypos (list): list of nbest lists of hypotheses
        
        Raises:
            OSError. If the directory could not be created
            IOError. If something goes wrong while writing to the disk
        """
        try:
            os.makedirs(self.path)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise
            else:
                logging.warn(
                        "Output FST directory %s already exists." % self.path)
        fst_idx = self.start_sen_id
        for hypos in all_hypos:
            fst_idx += 1
            with open(self.file_pattern % fst_idx, "w") as f:
                # state ID 0 is start, 1 is final state
                next_free_id = 2
                for hypo in hypos:
                    syms = hypo.trgt_sentence
                    # Connect with start node
                    f.write("0\t%d\t%d\t%d\n" % (next_free_id,
                                                 utils.GO_ID,
                                                 utils.GO_ID))
                    next_free_id += 1
                    for pos in xrange(len(hypo.score_breakdown)-1):
                        f.write("%d\t%d\t%d\t%d\t%s\n" % (
                          next_free_id-1, # last state id
                          next_free_id, # next state id 
                          syms[pos], syms[pos], # arc labels
                          self.write_weight(hypo.score_breakdown[pos])))
                        next_free_id += 1
                    # Connect with final node
                    f.write("%d\t1\t%d\t%d\t%s\n" % (
                                next_free_id-1,
                                utils.EOS_ID,
                                utils.EOS_ID,
                                self.write_weight(hypo.score_breakdown[-1])))
                f.write("1\n") # Add final node


class StandardFSTOutputHandler(OutputHandler):
    """This output handler creates text formatted FSTs with standard 
    arcs. In contrast to ``FSTOutputHandler``, predictor scores are
    combined using --combination_scheme.
    """
    
    def __init__(self, path, start_sen_id):
        """Creates a standard arc FST output handler.
        
        Args:
            path (string):  Path to the fst directory to create
            start_sen_id (int):  ID of the first sentence
        """
        super(StandardFSTOutputHandler, self).__init__()
        self.path = path
        self.start_sen_id = start_sen_id
        self.file_pattern = path + "/%d.fst.txt" 
      
    def write_hypos(self, all_hypos):
        """Writes FST files with standard arcs in text format for each
        sentence in ``all_hypos``. The created lattices are not 
        optimized in any way: We create a distinct path for each entry 
        in ``all_hypos``. We advise you to determinize/minimize them if
        you are planning to use them for further processing. However, 
        keep in mind that SGNMT uses the id 0 for UNK, and OpenFST marks
        epsilon arcs that way. You can resolve this clash by using 
        fstrelabel after fstcompile.
        
        Args:
            all_hypos (list): list of nbest lists of hypotheses
        
        Raises:
            OSError. If the directory could not be created
            IOError. If something goes wrong while writing to the disk
        """
        try:
            os.makedirs(self.path)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise
            else:
                logging.warn(
                        "Output FST directory %s already exists." % self.path)
        fst_idx = self.start_sen_id
        for hypos in all_hypos:
            fst_idx += 1
            with open(self.file_pattern % fst_idx, "w") as f:
                # state ID 0 is start, 1 is final state
                next_free_id = 2
                for hypo in hypos:
                    syms = hypo.trgt_sentence
                    # Connect with start node
                    f.write("0\t%d\t%d\t%d\t%f\n" % (next_free_id,
                                                     utils.GO_ID,
                                                     utils.GO_ID,
                                                     -hypo.total_score))
                    next_free_id += 1
                    for sym in hypo.trgt_sentence:
                        f.write("%d\t%d\t%d\t%d\n" % (next_free_id-1,
                                                      next_free_id,
                                                      sym, sym))
                        next_free_id += 1
                    # Connect with final node
                    f.write("%d\t1\t%d\t%d\n" % (next_free_id-1,
                                                 utils.EOS_ID,
                                                 utils.EOS_ID))
                f.write("1\n")
